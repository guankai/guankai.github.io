<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[mac上设置vim]]></title>
      <url>%2F2017%2F02%2F25%2Fmac-vim%2F</url>
      <content type="text"><![CDATA[copy vim 配置文件到个人文件目录 1cp /usr/share/vim/vimrc ~/.vimrc 如果只是需要设置语法高亮，则编辑~/.vimrc文件，在最后一行添加syntax on即可 如果还需要每次打开都会显示行号，则紧跟着添加 set nu! 其余选项如下 set nocompatible “去掉有关vi一致性模式，避免以前版本的bug和局限 set nu! “显示行号 set guifont=Luxi/ Mono/ 9 “ 设置字体，字体名称和字号 filetype on “检测文件的类型 set history=1000 “记录历史的行数 set background=dark “背景使用黑色 syntax on “语法高亮度显示 set autoindent “vim使用自动对齐，也就是把当前行的对齐格式应用到下一行(自动缩进） set cindent “（cindent是特别针对 C语言语法自动缩进） set smartindent “依据上面的对齐格式，智能的选择对齐方式，对于类似C语言编写上有用 set tabstop=4 “设置tab键为4个空格， set shiftwidth =4 “设置当行之间交错时使用4个空格 set ai! “ 设置自动缩进 set showmatch “设置匹配模式，类似当输入一个左括号时会匹配相应的右括号 set guioptions-=T “去除vim的GUI版本中得toolbar set vb t_vb= “当vim进行编辑时，如果命令错误，会发出警报，该设置去掉警报 set ruler “在编辑过程中，在右下角显示光标位置的状态行 set nohls “默认情况下，寻找匹配是高亮度显示，该设置关闭高亮显示 set incsearch “在程序中查询一单词，自动匹配单词的位置；如查询desk单词，当输到/d时，会自动找到第一个d开头的单词，当输入到/de时，会自动找到第一个以ds开头的单词，以此类推，进行查找；当找到要匹配的单词时，别忘记回车 set backspace=2 “ 设置退格键可用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何为动态分配的Virtualbox虚拟硬盘扩容]]></title>
      <url>%2F2017%2F02%2F23%2Fmac-virtualbox%2F</url>
      <content type="text"><![CDATA[查看虚拟硬盘是否动态分配大小打开虚拟机的设置界面，需要扩展虚拟硬盘机器的设置，在右边可以看到虚拟硬盘的设置信息 备份虚拟硬盘在我们为virtualbox虚拟硬盘扩容前，防止发生错误，需要先备份一下防止数据丢失 将右边位置对应路径就是虚拟硬盘的位置，将其复制下来 然后将虚拟硬盘从你的虚拟机上移除，通过点击-号 在宿主上打开一个终端，输入命令备份虚拟硬盘 1cp /location-of-virtual-disk /location-of-backup-of-virtual-disk 为virtualbox虚拟硬盘扩容现在，我们需要通过vboxmanage命令来为虚拟硬盘扩容，命令如下 1vboxmanage modifyhd /location-of-your-virtual-disk --resize size-in-MB 虚拟机的扩容单位是MB, 我将虚拟硬盘扩容为30GB 1vboxmanage modifyhd "/Users/guankai/VirtualBox VMs/Ubuntu/ubuntu.vdi" --resize 30720 Ps. 你不能用这个命令来缩减虚拟硬盘的容量 现在需要在virtualbox对应的虚拟机的设置中将这个扩容的vdi重新添加 如果对话框中没有显示你已经增加的存储，不用担心。只要启动虚拟机后在里面通过df命令看到这个新增的盘就行。 使用Gparted为Guest OS文件系统扩容虽然我们为虚拟硬盘扩容，可以Guest OS并不能使用新增的空间，我们需要一个OS的安装镜像启动虚拟机。通过镜像里面的Gparted这个工具对文件系统扩容 在virtualbox中设置从光驱启动，同时设置Guest OS的镜像文件 进入通过镜像启动的live系统后，在工具里面搜索Gparted并打开 新增的盘会以extended的形式出现，先把删除swap分区，删除extended，将现有的/dev/sda1通过拖拽增大（给swap留2G即可）接着创建extended，创建swap，应用。大功告成。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iron-functions初体验]]></title>
      <url>%2F2017%2F02%2F21%2FironFuncStart%2F</url>
      <content type="text"><![CDATA[serverless Serverless is a new paradigm in computing that enables simplicity, efficiency and scalability for both developers and operators serverless对于开发者以及运营人员都会带来不小的收益： 开发者：1.无需再关心服务器的管理，只需要上传自己的代码，平台会自动处理一切。2.无需再将自己的程序7*24小时的运行而付出高昂的费用，你的代码只有在需要的时候才会运行。 运营:1.机器的资源可以更加有效的得到合理的利用。2.更加容易的管理和扩容。 iron-io/functionsironFunctions是一个serverless的开源平台，按照时下流行的叫法就是FAAS(Functions As A Service)。 该平台的主要特性 write once：可以使用任何主流语言,同时支持AWS的lambda函数 run anywhere:可以在共有云，私有云以及混合云中运行，直接运行lambda function，目前支持python，nodejs，java quick startironFunctions官方提供了一些说明，让开发者可以快速体验它的功能。 前置条件docker 1.12或以后的版本 登录到一个docker hub（docker login） 运行ironFunctions1docker run --rm -it --name functions --privileged -v $&#123;PWD&#125;/data:/app/data -p 8080:8080 iron/functions 通过这个命令可以在你的机器上运行一个单节点的ironFunction，可以使用里面内嵌的database和message queue。 客户端工具安装ironFunctions的client 1curl -LSs http://get.iron.io/fn | sh 这个命令由于网络的原因经常会执行失败，不过不用担心，在浏览器上打链接，可以看到就是一段shell代码。里面的核心内容如下： 12345678910111213141516171819202122url='https://github.com/iron-io/functions/releases/download'# perform some very rudimentary platform detectioncase "$(uname)" in Linux) $sh_c "$curl /usr/local/bin/fn $url/$release/fn_linux" $sh_c "chmod +x /usr/local/bin/fn" fn --version exit 0 ;; Darwin) $sh_c "$curl /usr/local/bin/fn $url/$release/fn_mac" $sh_c "chmod +x /usr/local/bin/fn" fn --version exit 0 ;; WindowsNT) $sh_c "$curl $url/$release/fn.exe" # TODO how to make executable? chmod? fn.exe --version exit 0 ;; 判断你的OS,下载对应的fn版本，然后mv到/usr/local/bin/fn，所以当你执行上面那段语句失败，可以从fn client下载。 写一个函数在serverless里面种，函数就是很小的，可以执行单一的简单任务，官方提供了一个用go编写的function 1234567891011121314151617package mainimport ( "encoding/json" "fmt" "os")type Person struct &#123; Name string&#125;func main() &#123; p := &amp;Person&#123;Name: "World"&#125; json.NewDecoder(os.Stdin).Decode(p) fmt.Printf("Hello %v!", p.Name)&#125; 粘贴代码到func.go文件中，然后通过下面的命令构建并部署这个function 12# 通过functions的客户端命令，根据你源码的后缀，创建一个对应的yaml文件，同时在dockerhub上创建了对应的repository。fn init $USERNAME/hello yaml文件内容如下: 1234name: $USERNAME/helloversion: 0.0.1runtime: goentrypoint: ./func 12345678910# 构建函数，将函数制作成docker imagefn build# 运行进行，进行测试fn run# 将镜像push到docker hub对应的repositoryfn push# 创建一个appfn apps create myapp# 在app下创建一个路由，参数依次为 app名称，路由地址，镜像名称fn routes create myapp /hello $USERNAME/hello:0.0.1 这样我们就创建好第一个functions了。可以通过curl来进行测试 123curl http://localhost:8080/r/myapp/helloHello World! PS这个开始是在mac上搭建的。在已经拉取镜像的情况下，每次访问function的平均时间居然要1.15S左右，开始怀疑这个玩意是不是就是serverless概念的玩具。后来在ubuntu虚拟机上整了一套同样的环境。结果访问function的平均时间就在100ms左右了。后来专门查了下，发现他们官网针对这个也做过说明，的确是mac上的docker支持的不太好。看来玩docker还是要在ubuntu上呀。下图是官网的针对mac和ubuntu的对比截图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac下安装golang]]></title>
      <url>%2F2017%2F02%2F10%2F20170210-01%2F</url>
      <content type="text"><![CDATA[首先安装brewbrew是mac上的强大的包管理工具，类似ubuntu的apt-get以及centos的yum，属于mac上必装的软件。1234#在终端输入命令ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"#安装后更新下brew update 开始安装go1brew install go 设置go的环境变量在用户根目录下1vi ~/.bash_profile 1234# 设置gorootexport PATH=$PATH:/usr/local/opt/go/libexec/bin# 设置gopathexport GOPATH=/Users/yourname/go 使设置生效1source .bash_profile 如果使用了zsh，需要将以上的设置在~/.zshrc中再写一遍即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pkgcloud和curl创建openstack实例]]></title>
      <url>%2F2017%2F02%2F08%2F20170208-02%2F</url>
      <content type="text"><![CDATA[在通过了keyStone验证通过后，openstack响应endpoints数组，这些数组对应的是openstack的主要模块访问地址，例如nova，neutron等。neutron：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &#123; "endpoints": [&#123; "region_id": "RegionOne", "url": "http://xxx:9696", "region": "RegionOne", "interface": "internal", "id": "1b6abf4194024a5a88ad536836918d34" &#125;, &#123; "region_id": "RegionOne", "url": "http://xxx:9696", "region": "RegionOne", "interface": "admin", "id": "8b7315fa74654cb8b86641bd44351da4" &#125;, &#123; "region_id": "RegionOne", "url": "http://xxx:9696", // 这个就是可以通过外部访问的api，http schema "region": "RegionOne", "interface": "public", "id": "f895dc01a3424c1e955da86b7bdc63f2" &#125;], "type": "network", "id": "27c04c9ee6be457fa73671cf967aae19", "name": "neutron" &#125; 在需要获取network相关的api时，就可以通过这个public的url进行访问。 用户就可以与openstack进行交互查询image，flavor，networks等数据，作为创建虚拟机的参数。 curl方式 在验证keystone的请求中，需要加上参数 -i ，这样才能获取返回的header（token在header中存放），x-Subject-Token 12345678HTTP/1.1 201 CreatedDate: Fri, 28 Oct 2016 09:22:22 GMTServer: ApacheX-Subject-Token: gAAAAABYExjOa0G6p-5HkVwVxwFDJ7Dc_eXrkfGxQYUVF8sgD8WfQICNuQi76FAcQCvsayDPwiYGLOUQKjdmA2jA9FpGrmWWacBhn_fMbggN0gHAwkeWUrXg01JySJh7szvjHi0LqGo_OOY7NuJ34xpSPIp1A1sC__ETXvwpqMli9Va6JqqG8doVary: X-Auth-Tokenx-openstack-request-id: req-4fbf6557-066b-4135-818e-cc935e45e313Content-Length: 5407Content-Type: application/json 为了方便测试，可以将keystone验证返回的token和对应的url存放在变量中，1export OS_TOKEN=gAAAAABYExjOa0G6p-5HkVwVxwFDJ7Dc_eXrkfGxQYUVF8sgD8WfQICNuQi76FAcQCvsayDPwiYGLOUQKjdmA2jA9FpGrmWWacBhn_fMbggN0gHAwkeWUrXg01JySJh7szvjHi0LqGo_OOY7NuJ34xpSPIp1A1sC__ETXvwpqMli9Va6JqqG8do 获取flavors123curl -s -H "X-Auth-Token: $OS_TOKEN" \ $OS_COMPUTE_API/flavors \ | python -m json.tool 可以根据自己的需要从返回的配置中获取flavor1234567891011121314151617181920212223242526272829303132&#123; "flavors": [ &#123; "id": "1", "links": [ &#123; "href": "http://223.202.32.35:8774/v2.1/fc6ac8c46d8147fd9ffa7a32e373ff9a/flavors/1", "rel": "self" &#125;, &#123; "href": "http://223.202.32.35:8774/fc6ac8c46d8147fd9ffa7a32e373ff9a/flavors/1", "rel": "bookmark" &#125; ], "name": "m1.tiny" &#125;, &#123; "id": "2", "links": [ &#123; "href": "http://223.202.32.35:8774/v2.1/fc6ac8c46d8147fd9ffa7a32e373ff9a/flavors/2", "rel": "self" &#125;, &#123; "href": "http://223.202.32.35:8774/fc6ac8c46d8147fd9ffa7a32e373ff9a/flavors/2", "rel": "bookmark" &#125; ], "name": "m1.small" &#125;&#125; 获取image123curl -s -H "X-Auth-Token: $OS_TOKEN" \ $OS_IMAGE_API/v2/images \ | python -m json.tool 返回的json数据123456789101112131415161718192021222324252627&#123; "first": "/v2/images", "images": [ &#123; "checksum": "0d7ba90f5923297ee53351ce7e72ab76", "container_format": "bare", "created_at": "2016-10-19T09:19:36Z", "description": "", "disk_format": "qcow2", "file": "/v2/images/ea99659a-5109-49e3-9b0f-bf5345eb7d97/file", "id": "ea99659a-5109-49e3-9b0f-bf5345eb7d97", "min_disk": 10, "min_ram": 512, "name": "Centos 7", "owner": "4f9cfde31f7d42f096b766e4b95855e8", "protected": false, "schema": "/v2/schemas/image", "self": "/v2/images/ea99659a-5109-49e3-9b0f-bf5345eb7d97", "size": 377880576, "status": "active", "tags": [], "updated_at": "2016-10-26T08:56:33Z", "virtual_size": null, "visibility": "public" &#125;]&#125; 获取networks信息123curl -s -H "X-Auth-Token: $OS_TOKEN" \ $OS_NETWORKS_API/v2.0/networks \ | python -m json.tool 返回的json，其中在后面需要使用的一个是service，主要负责内网ip的分配，另一个是public，进行公网IP的分配1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&#123; "networks": [ &#123; "admin_state_up": true, "availability_zone_hints": [], "availability_zones": [ "nova" ], "created_at": "2016-10-08T07:09:20", "description": "", "id": "38d9d825-256b-4477-939b-42714a28776d", "ipv4_address_scope": null, "ipv6_address_scope": null, "mtu": 1450, "name": "HA network tenant 4f9cfde31f7d42f096b766e4b95855e8", "port_security_enabled": true, "provider:network_type": "vxlan", "provider:physical_network": null, "provider:segmentation_id": 9, "router:external": false, "shared": false, "status": "ACTIVE", "subnets": [ "2aea08cf-4027-4569-86b4-63646f6dd2b2" ], "tags": [], "tenant_id": "", "updated_at": "2016-10-08T07:09:20" &#125;, &#123; "admin_state_up": true, "availability_zone_hints": [], "availability_zones": [ "nova" ], "created_at": "2016-10-08T09:11:03", "description": "", "id": "baa3dbad-5994-4837-9263-32304ee7d035", "ipv4_address_scope": null, "ipv6_address_scope": null, "is_default": false, "mtu": 1500, "name": "public", "port_security_enabled": true, "provider:network_type": "vlan", "provider:physical_network": "vlan", "provider:segmentation_id": 40, "router:external": true, "shared": true, "status": "ACTIVE", "subnets": [ "a2c44a10-6f23-42dd-b7d8-c3319d542628" ], "tags": [], "tenant_id": "4f9cfde31f7d42f096b766e4b95855e8", "updated_at": "2016-10-08T09:19:18" &#125;, &#123; "admin_state_up": true, "availability_zone_hints": [], "availability_zones": [ "nova" ], "created_at": "2016-10-09T04:04:29", "description": "", "id": "f3411c78-f02a-4556-9171-4e9e5b102b20", "ipv4_address_scope": null, "ipv6_address_scope": null, "mtu": 1450, "name": "service", "port_security_enabled": true, "provider:network_type": "vxlan", "provider:physical_network": null, "provider:segmentation_id": 71, "router:external": false, "shared": true, "status": "ACTIVE", "subnets": [ "a76d00f6-752a-40af-bbcd-fefb6a33fef0" ], "tags": [], "tenant_id": "4f9cfde31f7d42f096b766e4b95855e8", "updated_at": "2016-10-10T05:43:49" &#125; ]&#125; 有了这些参数基本上就可以创建一个虚拟机实例了。12345678910 curl -is -H "X-Auth-Token: $OS_TOKEN" \ -H "Content-Type: application/json" \ -d '&#123; "server": &#123; "name": "patrick-vm", "imageRef": "fff2aa1b-dd06-4dbf-b259-652057615f4b", "flavorRef": "2", "networks": [&#123;"uuid": "f3411c78-f02a-4556-9171-4e9e5b102b20"&#125;] &#125;&#125;' \ $OS_COMPUTE_API/servers 如果需要采用keyPairs的方式登录创建的虚拟机。添加参数key_name即可，对应的value就是秘钥对的名字 如果需要在虚拟机创建后，执行相应的脚本。则需要添加user_data这个参数，脚本的编写方式需要满足cloud-init要求，该参数填写前，需要将脚本编码为base64格式。 添加参数后的请求如下:123456789101112 curl -is -H "X-Auth-Token: $OS_TOKEN" \ -H "Content-Type: application/json" \ -d '&#123; "server": &#123; "name": "patrick-vm", "imageRef": "fff2aa1b-dd06-4dbf-b259-652057615f4b", "flavorRef": "2", "networks": [&#123;"uuid": "f3411c78-f02a-4556-9171-4e9e5b102b20"&#125;], "user_data": "IyEvYmluL3NoIAplY2hvICJIZWxsbyBXb3JsZC4gIFRoZSB0aW1lIGlzIG5vdyAkKGRhdGUgLVIpISIgfCB0ZWUgL3Jvb3Qvb3V0cHV0LnR4dCAK", "key_name": "op-key" &#125;&#125;' \ $OS_COMPUTE_API/servers 其中user_data对应的原文为123#!/bin/shecho "Hello World. The time is now $(date -R)!" | tee /root/output.txt pkgcloud 由于pkgcloud在createClient后将对应的url和token都存放在client对象中，所以过程相对简单很多 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var pkgcloud = require('pkgcloud'), _ = require('lodash');var cc = pkgcloud.compute.createClient(&#123; provider: 'openstack', // required username: '$user_name', // required password: '$user_pass', // required region: 'RegionOne', keystoneAuthVersion: 'v3', domainId: 'Default', tenantId: 'fc6ac8c46d8147fd9ffa7a32e373ff9a', domainName: 'Default', authUrl: 'http://xxxx:5000' // required&#125;);var nc = pkgcloud.network.createClient(&#123; provider: 'openstack', // required username: '$user_name', // required password: '$user_pass', // required region: 'RegionOne', keystoneAuthVersion: 'v3', domainId: 'Default', tenantId: 'fc6ac8c46d8147fd9ffa7a32e373ff9a', domainName: 'Default', authUrl: 'http://xxxx:5000' // required&#125;);cc.getFlavors(function(err, flavors) &#123; if (err) &#123; console.error(err); return; &#125; cc.getImages(function(err, images) &#123; if (err) &#123; console.log(err); return; &#125; var flavor = _.findWhere(flavors, &#123; name: 'm1.small' &#125;); var image = _.findWhere(images, &#123; name: 'ubuntu14.04' &#125;); var userData = '#!/bin/sh \n'; userData += 'echo "Hello World. The time is now $(date -R)!" | tee /root/output.txt \n'; var userData64 = new Buffer(userData).toString("base64"); cc.createServer(&#123; name: 'patrick_client', image: image, flavor: flavor, networks: [&#123; uuid: 'f3411c78-f02a-4556-9171-4e9e5b102b20' &#125;], cloudConfig: userData64, securityGroups: [&#123; name: 'default' &#125;], keyname: 'op-key' &#125;, handleServerResponse); &#125;);&#125;); 过程虽然比较简单，但是参数比较坑，比如user_data的参数映射为了cloudConfig]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[openstack和pkgcloud的认证]]></title>
      <url>%2F2017%2F02%2F08%2F20170208-01%2F</url>
      <content type="text"><![CDATA[pkgcloud作为openstack的官方指定nodejs的SDK，可以支持M版本的大部分api，下面主要说一下在认证（keystone）方面针对v2和v3两个版本差异 v2openstack官方提供了一个通过curl的方法，如下 1234 $ curl -s -X POST $OS_AUTH_URL/tokens \ -H "Content-Type: application/json" \ -d '&#123;"auth": &#123;"tenantName": "'"$OS_PROJECT_NAME"'", "passwordCredentials": &#123;"username": "'"$OS_USERNAME"'", "password": "'"$OS_PASSWORD"'"&#125;&#125;&#125;' \ | python -m json.tool 其中如果没有对应的project，可以不用填写tenantName，后续的操作可以使用response中返回的token作为请求参数，注意过期日期即可。 pkgcloud中对应的方法如下12345678var pkgcloud = require('pkgcloud');var cc = pkgcloud.compute.createClient(&#123; provider: 'openstack', // required username: '$user_name', // required password: '$user_pass', // required region: 'RegionOne', //在开发阶段，需要将这个设置为RegionOne authUrl: '$auth_url' // required&#125;); 获取的cc对象可以进行后续的操作，例如cc.getServers()等 v3在v3版本中，对应的参数结构发生了变化,官方提供的curl方法如下12345678910111213141516171819curl -s -X POST $auth_url/v3/auth/tokens \ -H "Content-Type: application/json" \ -d '&#123;"auth": &#123; "identity": &#123; "methods": [ "password" ], "password": &#123; "user": &#123; "name": "$user_name", "domain": &#123; "name": "Default" &#125;, "password": "$user_pass" &#125; &#125; &#125; &#125;&#125;' \ | python3 -m json.tool 在请求的参数中，多了一个domain的key，此处填写’Default’即可 pkgcloud对应方法如下，主要需要添加keystoneAuthVersion 设置为v3，同时设置tenantId和domainId12345678910111213var pkgcloud = require('pkgcloud');var cc = pkgcloud.compute.createClient(&#123; provider: 'openstack', // required username: '$user_name', // required password: '$user_pass', // required region: 'RegionOne', keystoneAuthVersion: 'v3', domainId: 'Default', tenantId: 'fc6ac8c46d8147fd9ffa7a32e373ff9a', domainName: 'Default', authUrl: '$auth_url' // required&#125;); 目前这个sdk还在完善阶段，很多的东西都没有在wiki和doc上体现，需要对着openstack的API一点点的排查，需要做的工作还很多呀。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python生成javabean]]></title>
      <url>%2F2017%2F02%2F07%2F20170207-01%2F</url>
      <content type="text"><![CDATA[python作为一个简洁的语言，在作为工具、监控以及运维等方面的使用上的确令人耳目一新。于是尝试使用python做一个简陋的javaBean生成工具，目前很多人喜欢在数据库表命名的时候采用underline的方式如”xx_xx_table”，而javabean的命名通常为camel方式，如”myBean”。下面看看python能做些什么。 首先需要连接到数据库，获取生成javabean对应数据库表的信息 1234567891011import pymysqlconn = pymysql.connect(host=_host,user=_user,passwd=_pass,db=_sid,port=3306,charset='utf8')cur = conn.cursor()sql ='select * from '+ _tableNamecur.execute(sql)desc = cur.description 从cur.description可以获取数据库表的字段名称以及类型，字段类型使用数字进行标注，以下是字段类型对照关系12345678910111213141516171=&gt;'tinyint', 2=&gt;'smallint', 3=&gt;'int', 4=&gt;'float', 5=&gt;'double', 7=&gt;'timestamp', 8=&gt;'bigint', 9=&gt;'mediumint', 10=&gt;'date', 11=&gt;'time', 12=&gt;'datetime', 13=&gt;'year', 16=&gt;'bit', //252 is currently mapped to all text and blob types (MySQL 5.0.51a) 253=&gt;'varchar', 254=&gt;'char', 246=&gt;'decimal' 有了以上的这些信息，剩下的事情就简单了。只需要把字段转成camel方式即可 123456def underline_to_camel(underline_format): camel_format = '' if isinstance(underline_format, str): for _s_ in underline_format.split('_'): camel_format += _s_.capitalize() return camel_format 上面这个函数转出来的效果所有首字母大写。这个可以在循环里面单独处理，或者对已经生成的camel字符串处理即可1newCamel = camel[0].lower() + camel[1:] 拼装javabean。123456789101112131415161718for line in desc: #根据mysql类型以及自己的需要对dateType进行转换 if line[1] in (1, 2, 3, 8, 9, 246): dataType = 'int' elif line[1] in (4, 5): dataType = 'double' else: dataType = 'String' #转换camel写法，并拼装javabean beanName = underline_to_camel(line[0], 'V') funcName = underline_to_camel(line[0], 'F') lineStr = " /** \n" lineStr += " * 字段" + beanName + "\n" lineStr += " */\n" lineStr += " private " + dataType + " " + beanName + ";\n" lineStr += " public " + dataType + " get" + funcName + "() &#123; return " + beanName + "; &#125;\n" lineStr += " public void set" + funcName + "(" + dataType + " " + beanName + ") &#123; this." + beanName + " = " + beanName + "; &#125;\n" beanList.append(lineStr) 拼装完成后，写文件，关闭数据库连接就完成了这个乞丐版的javabean生成工具了。依次类推还可以生成DAO,XML]]></content>
    </entry>

    
  
  
</search>
