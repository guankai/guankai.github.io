<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Mac下安装golang]]></title>
      <url>%2F2017%2F02%2F10%2F20170210-01%2F</url>
      <content type="text"><![CDATA[首先安装brewbrew是mac上的强大的包管理工具，类似ubuntu的apt-get以及centos的yum，属于mac上必装的软件。1234#在终端输入命令ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"#安装后更新下brew update 开始安装go1brew install go 设置go的环境变量在用户根目录下1vi ~/.bash_profile 1234# 设置gorootexport PATH=$PATH:/usr/local/opt/go/libexec/bin# 设置gopathexport GOPATH=/Users/yourname/go 使设置生效1source .bash_profile 如果使用了zsh，需要将以上的设置在~/.zshrc中再写一遍即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pkgcloud和curl创建openstack实例]]></title>
      <url>%2F2017%2F02%2F08%2F20170208-02%2F</url>
      <content type="text"><![CDATA[在通过了keyStone验证通过后，openstack响应endpoints数组，这些数组对应的是openstack的主要模块访问地址，例如nova，neutron等。neutron：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &#123; "endpoints": [&#123; "region_id": "RegionOne", "url": "http://xxx:9696", "region": "RegionOne", "interface": "internal", "id": "1b6abf4194024a5a88ad536836918d34" &#125;, &#123; "region_id": "RegionOne", "url": "http://xxx:9696", "region": "RegionOne", "interface": "admin", "id": "8b7315fa74654cb8b86641bd44351da4" &#125;, &#123; "region_id": "RegionOne", "url": "http://xxx:9696", // 这个就是可以通过外部访问的api，http schema "region": "RegionOne", "interface": "public", "id": "f895dc01a3424c1e955da86b7bdc63f2" &#125;], "type": "network", "id": "27c04c9ee6be457fa73671cf967aae19", "name": "neutron" &#125; 在需要获取network相关的api时，就可以通过这个public的url进行访问。 用户就可以与openstack进行交互查询image，flavor，networks等数据，作为创建虚拟机的参数。 curl方式 在验证keystone的请求中，需要加上参数 -i ，这样才能获取返回的header（token在header中存放），x-Subject-Token 12345678HTTP/1.1 201 CreatedDate: Fri, 28 Oct 2016 09:22:22 GMTServer: ApacheX-Subject-Token: gAAAAABYExjOa0G6p-5HkVwVxwFDJ7Dc_eXrkfGxQYUVF8sgD8WfQICNuQi76FAcQCvsayDPwiYGLOUQKjdmA2jA9FpGrmWWacBhn_fMbggN0gHAwkeWUrXg01JySJh7szvjHi0LqGo_OOY7NuJ34xpSPIp1A1sC__ETXvwpqMli9Va6JqqG8doVary: X-Auth-Tokenx-openstack-request-id: req-4fbf6557-066b-4135-818e-cc935e45e313Content-Length: 5407Content-Type: application/json 为了方便测试，可以将keystone验证返回的token和对应的url存放在变量中，1export OS_TOKEN=gAAAAABYExjOa0G6p-5HkVwVxwFDJ7Dc_eXrkfGxQYUVF8sgD8WfQICNuQi76FAcQCvsayDPwiYGLOUQKjdmA2jA9FpGrmWWacBhn_fMbggN0gHAwkeWUrXg01JySJh7szvjHi0LqGo_OOY7NuJ34xpSPIp1A1sC__ETXvwpqMli9Va6JqqG8do 获取flavors123curl -s -H "X-Auth-Token: $OS_TOKEN" \ $OS_COMPUTE_API/flavors \ | python -m json.tool 可以根据自己的需要从返回的配置中获取flavor1234567891011121314151617181920212223242526272829303132&#123; "flavors": [ &#123; "id": "1", "links": [ &#123; "href": "http://223.202.32.35:8774/v2.1/fc6ac8c46d8147fd9ffa7a32e373ff9a/flavors/1", "rel": "self" &#125;, &#123; "href": "http://223.202.32.35:8774/fc6ac8c46d8147fd9ffa7a32e373ff9a/flavors/1", "rel": "bookmark" &#125; ], "name": "m1.tiny" &#125;, &#123; "id": "2", "links": [ &#123; "href": "http://223.202.32.35:8774/v2.1/fc6ac8c46d8147fd9ffa7a32e373ff9a/flavors/2", "rel": "self" &#125;, &#123; "href": "http://223.202.32.35:8774/fc6ac8c46d8147fd9ffa7a32e373ff9a/flavors/2", "rel": "bookmark" &#125; ], "name": "m1.small" &#125;&#125; 获取image123curl -s -H "X-Auth-Token: $OS_TOKEN" \ $OS_IMAGE_API/v2/images \ | python -m json.tool 返回的json数据123456789101112131415161718192021222324252627&#123; "first": "/v2/images", "images": [ &#123; "checksum": "0d7ba90f5923297ee53351ce7e72ab76", "container_format": "bare", "created_at": "2016-10-19T09:19:36Z", "description": "", "disk_format": "qcow2", "file": "/v2/images/ea99659a-5109-49e3-9b0f-bf5345eb7d97/file", "id": "ea99659a-5109-49e3-9b0f-bf5345eb7d97", "min_disk": 10, "min_ram": 512, "name": "Centos 7", "owner": "4f9cfde31f7d42f096b766e4b95855e8", "protected": false, "schema": "/v2/schemas/image", "self": "/v2/images/ea99659a-5109-49e3-9b0f-bf5345eb7d97", "size": 377880576, "status": "active", "tags": [], "updated_at": "2016-10-26T08:56:33Z", "virtual_size": null, "visibility": "public" &#125;]&#125; 获取networks信息123curl -s -H "X-Auth-Token: $OS_TOKEN" \ $OS_NETWORKS_API/v2.0/networks \ | python -m json.tool 返回的json，其中在后面需要使用的一个是service，主要负责内网ip的分配，另一个是public，进行公网IP的分配1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&#123; "networks": [ &#123; "admin_state_up": true, "availability_zone_hints": [], "availability_zones": [ "nova" ], "created_at": "2016-10-08T07:09:20", "description": "", "id": "38d9d825-256b-4477-939b-42714a28776d", "ipv4_address_scope": null, "ipv6_address_scope": null, "mtu": 1450, "name": "HA network tenant 4f9cfde31f7d42f096b766e4b95855e8", "port_security_enabled": true, "provider:network_type": "vxlan", "provider:physical_network": null, "provider:segmentation_id": 9, "router:external": false, "shared": false, "status": "ACTIVE", "subnets": [ "2aea08cf-4027-4569-86b4-63646f6dd2b2" ], "tags": [], "tenant_id": "", "updated_at": "2016-10-08T07:09:20" &#125;, &#123; "admin_state_up": true, "availability_zone_hints": [], "availability_zones": [ "nova" ], "created_at": "2016-10-08T09:11:03", "description": "", "id": "baa3dbad-5994-4837-9263-32304ee7d035", "ipv4_address_scope": null, "ipv6_address_scope": null, "is_default": false, "mtu": 1500, "name": "public", "port_security_enabled": true, "provider:network_type": "vlan", "provider:physical_network": "vlan", "provider:segmentation_id": 40, "router:external": true, "shared": true, "status": "ACTIVE", "subnets": [ "a2c44a10-6f23-42dd-b7d8-c3319d542628" ], "tags": [], "tenant_id": "4f9cfde31f7d42f096b766e4b95855e8", "updated_at": "2016-10-08T09:19:18" &#125;, &#123; "admin_state_up": true, "availability_zone_hints": [], "availability_zones": [ "nova" ], "created_at": "2016-10-09T04:04:29", "description": "", "id": "f3411c78-f02a-4556-9171-4e9e5b102b20", "ipv4_address_scope": null, "ipv6_address_scope": null, "mtu": 1450, "name": "service", "port_security_enabled": true, "provider:network_type": "vxlan", "provider:physical_network": null, "provider:segmentation_id": 71, "router:external": false, "shared": true, "status": "ACTIVE", "subnets": [ "a76d00f6-752a-40af-bbcd-fefb6a33fef0" ], "tags": [], "tenant_id": "4f9cfde31f7d42f096b766e4b95855e8", "updated_at": "2016-10-10T05:43:49" &#125; ]&#125; 有了这些参数基本上就可以创建一个虚拟机实例了。12345678910 curl -is -H "X-Auth-Token: $OS_TOKEN" \ -H "Content-Type: application/json" \ -d '&#123; "server": &#123; "name": "patrick-vm", "imageRef": "fff2aa1b-dd06-4dbf-b259-652057615f4b", "flavorRef": "2", "networks": [&#123;"uuid": "f3411c78-f02a-4556-9171-4e9e5b102b20"&#125;] &#125;&#125;' \ $OS_COMPUTE_API/servers 如果需要采用keyPairs的方式登录创建的虚拟机。添加参数key_name即可，对应的value就是秘钥对的名字 如果需要在虚拟机创建后，执行相应的脚本。则需要添加user_data这个参数，脚本的编写方式需要满足cloud-init要求，该参数填写前，需要将脚本编码为base64格式。 添加参数后的请求如下:123456789101112 curl -is -H "X-Auth-Token: $OS_TOKEN" \ -H "Content-Type: application/json" \ -d '&#123; "server": &#123; "name": "patrick-vm", "imageRef": "fff2aa1b-dd06-4dbf-b259-652057615f4b", "flavorRef": "2", "networks": [&#123;"uuid": "f3411c78-f02a-4556-9171-4e9e5b102b20"&#125;], "user_data": "IyEvYmluL3NoIAplY2hvICJIZWxsbyBXb3JsZC4gIFRoZSB0aW1lIGlzIG5vdyAkKGRhdGUgLVIpISIgfCB0ZWUgL3Jvb3Qvb3V0cHV0LnR4dCAK", "key_name": "op-key" &#125;&#125;' \ $OS_COMPUTE_API/servers 其中user_data对应的原文为123#!/bin/shecho "Hello World. The time is now $(date -R)!" | tee /root/output.txt pkgcloud 由于pkgcloud在createClient后将对应的url和token都存放在client对象中，所以过程相对简单很多 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var pkgcloud = require('pkgcloud'), _ = require('lodash');var cc = pkgcloud.compute.createClient(&#123; provider: 'openstack', // required username: '$user_name', // required password: '$user_pass', // required region: 'RegionOne', keystoneAuthVersion: 'v3', domainId: 'Default', tenantId: 'fc6ac8c46d8147fd9ffa7a32e373ff9a', domainName: 'Default', authUrl: 'http://xxxx:5000' // required&#125;);var nc = pkgcloud.network.createClient(&#123; provider: 'openstack', // required username: '$user_name', // required password: '$user_pass', // required region: 'RegionOne', keystoneAuthVersion: 'v3', domainId: 'Default', tenantId: 'fc6ac8c46d8147fd9ffa7a32e373ff9a', domainName: 'Default', authUrl: 'http://xxxx:5000' // required&#125;);cc.getFlavors(function(err, flavors) &#123; if (err) &#123; console.error(err); return; &#125; cc.getImages(function(err, images) &#123; if (err) &#123; console.log(err); return; &#125; var flavor = _.findWhere(flavors, &#123; name: 'm1.small' &#125;); var image = _.findWhere(images, &#123; name: 'ubuntu14.04' &#125;); var userData = '#!/bin/sh \n'; userData += 'echo "Hello World. The time is now $(date -R)!" | tee /root/output.txt \n'; var userData64 = new Buffer(userData).toString("base64"); cc.createServer(&#123; name: 'patrick_client', image: image, flavor: flavor, networks: [&#123; uuid: 'f3411c78-f02a-4556-9171-4e9e5b102b20' &#125;], cloudConfig: userData64, securityGroups: [&#123; name: 'default' &#125;], keyname: 'op-key' &#125;, handleServerResponse); &#125;);&#125;); 过程虽然比较简单，但是参数比较坑，比如user_data的参数映射为了cloudConfig]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[openstack和pkgcloud的认证]]></title>
      <url>%2F2017%2F02%2F08%2F20170208-01%2F</url>
      <content type="text"><![CDATA[pkgcloud作为openstack的官方指定nodejs的SDK，可以支持M版本的大部分api，下面主要说一下在认证（keystone）方面针对v2和v3两个版本差异 v2openstack官方提供了一个通过curl的方法，如下 1234 $ curl -s -X POST $OS_AUTH_URL/tokens \ -H "Content-Type: application/json" \ -d '&#123;"auth": &#123;"tenantName": "'"$OS_PROJECT_NAME"'", "passwordCredentials": &#123;"username": "'"$OS_USERNAME"'", "password": "'"$OS_PASSWORD"'"&#125;&#125;&#125;' \ | python -m json.tool 其中如果没有对应的project，可以不用填写tenantName，后续的操作可以使用response中返回的token作为请求参数，注意过期日期即可。 pkgcloud中对应的方法如下12345678var pkgcloud = require('pkgcloud');var cc = pkgcloud.compute.createClient(&#123; provider: 'openstack', // required username: '$user_name', // required password: '$user_pass', // required region: 'RegionOne', //在开发阶段，需要将这个设置为RegionOne authUrl: '$auth_url' // required&#125;); 获取的cc对象可以进行后续的操作，例如cc.getServers()等 v3在v3版本中，对应的参数结构发生了变化,官方提供的curl方法如下12345678910111213141516171819curl -s -X POST $auth_url/v3/auth/tokens \ -H "Content-Type: application/json" \ -d '&#123;"auth": &#123; "identity": &#123; "methods": [ "password" ], "password": &#123; "user": &#123; "name": "$user_name", "domain": &#123; "name": "Default" &#125;, "password": "$user_pass" &#125; &#125; &#125; &#125;&#125;' \ | python3 -m json.tool 在请求的参数中，多了一个domain的key，此处填写’Default’即可 pkgcloud对应方法如下，主要需要添加keystoneAuthVersion 设置为v3，同时设置tenantId和domainId12345678910111213var pkgcloud = require('pkgcloud');var cc = pkgcloud.compute.createClient(&#123; provider: 'openstack', // required username: '$user_name', // required password: '$user_pass', // required region: 'RegionOne', keystoneAuthVersion: 'v3', domainId: 'Default', tenantId: 'fc6ac8c46d8147fd9ffa7a32e373ff9a', domainName: 'Default', authUrl: '$auth_url' // required&#125;); 目前这个sdk还在完善阶段，很多的东西都没有在wiki和doc上体现，需要对着openstack的API一点点的排查，需要做的工作还很多呀。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python生成javabean]]></title>
      <url>%2F2017%2F02%2F07%2F20170207-01%2F</url>
      <content type="text"><![CDATA[python作为一个简洁的语言，在作为工具、监控以及运维等方面的使用上的确令人耳目一新。于是尝试使用python做一个简陋的javaBean生成工具，目前很多人喜欢在数据库表命名的时候采用underline的方式如”xx_xx_table”，而javabean的命名通常为camel方式，如”myBean”。下面看看python能做些什么。 首先需要连接到数据库，获取生成javabean对应数据库表的信息 1234567891011import pymysqlconn = pymysql.connect(host=_host,user=_user,passwd=_pass,db=_sid,port=3306,charset='utf8')cur = conn.cursor()sql ='select * from '+ _tableNamecur.execute(sql)desc = cur.description 从cur.description可以获取数据库表的字段名称以及类型，字段类型使用数字进行标注，以下是字段类型对照关系12345678910111213141516171=&gt;'tinyint', 2=&gt;'smallint', 3=&gt;'int', 4=&gt;'float', 5=&gt;'double', 7=&gt;'timestamp', 8=&gt;'bigint', 9=&gt;'mediumint', 10=&gt;'date', 11=&gt;'time', 12=&gt;'datetime', 13=&gt;'year', 16=&gt;'bit', //252 is currently mapped to all text and blob types (MySQL 5.0.51a) 253=&gt;'varchar', 254=&gt;'char', 246=&gt;'decimal' 有了以上的这些信息，剩下的事情就简单了。只需要把字段转成camel方式即可 123456def underline_to_camel(underline_format): camel_format = '' if isinstance(underline_format, str): for _s_ in underline_format.split('_'): camel_format += _s_.capitalize() return camel_format 上面这个函数转出来的效果所有首字母大写。这个可以在循环里面单独处理，或者对已经生成的camel字符串处理即可1newCamel = camel[0].lower() + camel[1:] 拼装javabean。123456789101112131415161718for line in desc: #根据mysql类型以及自己的需要对dateType进行转换 if line[1] in (1, 2, 3, 8, 9, 246): dataType = 'int' elif line[1] in (4, 5): dataType = 'double' else: dataType = 'String' #转换camel写法，并拼装javabean beanName = underline_to_camel(line[0], 'V') funcName = underline_to_camel(line[0], 'F') lineStr = " /** \n" lineStr += " * 字段" + beanName + "\n" lineStr += " */\n" lineStr += " private " + dataType + " " + beanName + ";\n" lineStr += " public " + dataType + " get" + funcName + "() &#123; return " + beanName + "; &#125;\n" lineStr += " public void set" + funcName + "(" + dataType + " " + beanName + ") &#123; this." + beanName + " = " + beanName + "; &#125;\n" beanList.append(lineStr) 拼装完成后，写文件，关闭数据库连接就完成了这个乞丐版的javabean生成工具了。依次类推还可以生成DAO,XML]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac下安装golang]]></title>
      <url>%2F2017%2F02%2F07%2Fgolang%2F</url>
      <content type="text"><![CDATA[1.首先安装brewbrew是mac上的强大的包管理工具，类似ubuntu的apt-get以及centos的yum，属于mac上必装的软件。1234#在终端输入命令ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"#安装后更新下brew update 2.开始安装go1brew install go 3.设置go的环境变量在用户根目录下1vi ~/.bash_profile 1234# 设置gorootexport PATH=$PATH:/usr/local/opt/go/libexec/bin# 设置gopathexport GOPATH=/Users/yourname/go 使设置生效1source .bash_profile 4.如果使用了zsh，需要将以上的设置在~/.zshrc中再写一遍即可。]]></content>
    </entry>

    
  
  
</search>
